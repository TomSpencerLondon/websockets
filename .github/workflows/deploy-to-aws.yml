name: Deploy to AWS

on:
  workflow_dispatch:  # Allows manual triggering of the workflow

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      # Set up AWS credentials
      - name: Set up AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set up Docker Compose
        run: |
          sudo apt-get install docker-compose

      - name: Build Docker image with Docker Compose
        run: |
          docker-compose -f docker-compose.yml build spring-boot-app
          docker images

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Tag Docker image for ECR
        run: |
          IMAGE_TAG="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_REPOSITORY }}:latest"
          docker tag spring-boot-app:latest $IMAGE_TAG

      - name: Push Docker image to Amazon ECR
        run: |
          IMAGE_TAG="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_REPOSITORY }}:latest"
          docker push $IMAGE_TAG

      - name: Register ECS Task Definition
        run: |
          TASK_DEFINITION_JSON=$(cat <<EOF
          {
            "family": "${{ secrets.TASK_DEFINITION_NAME }}",
            "networkMode": "awsvpc",
            "containerDefinitions": [
              {
                "name": "spring-container",
                "image": "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_REPOSITORY }}:latest",
                "memory": 512,
                "cpu": 256,
                "essential": true,
                "portMappings": [
                  {
                    "containerPort": 8080,
                    "hostPort": 8080,
                    "protocol": "tcp"
                  }
                ]
              }
            ],
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "256",
            "memory": "512",
            "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsWebsocketsECSTaskExecution"
          }
          EOF
          )
          echo "$TASK_DEFINITION_JSON" > task-def.json
          aws ecs register-task-definition --cli-input-json file://task-def.json

      - name: Deploy to ECS
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_NAME }} \
            --force-new-deployment

      - name: Get ECS Task Public IP
        run: |
          # Get the task ARN
          TASK_ARN=$(aws ecs list-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service-name ${{ secrets.ECS_SERVICE_NAME }} \
            --query "taskArns[0]" \
            --output text)

          # Check if a valid task ARN was found
          if [ "$TASK_ARN" == "None" ] || [ -z "$TASK_ARN" ]; then
            echo "No tasks found or task ARN is invalid"
            exit 1
          fi

          # Get the network interface ID associated with the task
          NETWORK_INTERFACE_ID=$(aws ecs describe-tasks \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --tasks $TASK_ARN \
            --query "tasks[0].attachments[0].details[?name=='networkInterfaceId'].value" \
            --output text)

          # Check if a valid network interface ID was found
          if [ "$NETWORK_INTERFACE_ID" == "None" ] || [ -z "$NETWORK_INTERFACE_ID" ]; then
            echo "No network interface found for task"
            exit 1
          fi

          # Get the Public IP address associated with the network interface
          PUBLIC_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $NETWORK_INTERFACE_ID \
            --query "NetworkInterfaces[0].Association.PublicIp" \
            --output text)

          # Check if a valid public IP was found
          if [ "$PUBLIC_IP" == "None" ] || [ -z "$PUBLIC_IP" ]; then
            echo "No public IP found for the task"
            exit 1
          fi

          # Display the Public IP address
          echo "Your application is running at: http://$PUBLIC_IP:8080"

      - name: Tear Down ECS Service (Optional)
        if: github.event.inputs.teardown == 'true'
        run: |
          aws ecs update-service \
            --cluster ${{ secrets.ECS_CLUSTER }} \
            --service ${{ secrets.ECS_SERVICE_NAME }} \
            --desired-count 0
